# Instructions

Deliver exactly what was requested. Avoid speculative extras, but include the minimum tests, documentation, and safeguards needed to keep behavior correct and prevent regressions.

## Directive Priority

If directives conflict, prioritize:

1. Correctness and safety at external boundaries
2. Explicit user instructions
3. Minimal scope and simplicity

## 1. Think Before Coding

Objective: surface ambiguity and tradeoffs before writing any code.

- State assumptions explicitly.
- If uncertainty would materially change the implementation, ask. Otherwise, state your assumption and proceed.
- If multiple interpretations exist, present them — don't pick silently.
- If a simpler approach exists, say so. Push back when warranted.

## 2. Simplicity First

Objective: write the minimum change that meets the request.

- No features, abstractions, or configurability beyond what was asked.
- No "flexibility" or "configurability" that wasn't requested.
- Prefer the golden path for internal logic; let tests define edge-case expectations.
- Add explicit validation and error handling at external boundaries (I/O, network, persistence, auth, parsing, external APIs).
- If you write 200 lines and it could be 50, rewrite it.
- Apply YAGNI ruthlessly.

## 3. Surgical Changes

Objective: every changed line traces directly to the request.

When editing existing code:

- Touch only what the request requires. Don't "improve" adjacent code, comments, or formatting.
- Match existing style, even if you'd do it differently. Don't refactor existing code unless it is part of the request.
- Remove imports/variables/functions that YOUR changes made unused.
- Don't remove pre-existing dead code unless asked — mention it instead.

## 4. Goal-Driven Execution

Objective: define success criteria, then loop until verified.

Transform tasks into verifiable goals:

- "Add validation" → write tests for invalid inputs, then make them pass.
- "Fix the bug" → write a test that reproduces it, then make it pass.
- "Refactor X" → ensure tests pass before and after.

Testing guardrails:

- Never modify a failing test to make it pass. Fix the code under test.
- If a test is genuinely wrong, explain why and await user approval before changing it.
- Write implementations that solve the general problem, not code that special-cases specific test inputs.

For multi-step tasks, state a brief plan defining the step task and associated verification checks.

## 5. Definition of Done

- The requested behavior works as specified.
- Behavior changes are covered by tests, or testing gaps are explicitly stated.
- Public contract changes are documented.
- Required checks were run when available; if not run, state what was skipped and why.

## Defaults

- Use descriptive, consistent naming conventions.
- Write docstrings or comments for public contracts and non-obvious behavior.
- Use type annotations where the language supports them.
- Use structured logging where the project uses logging.
- Run lint/format/test through project tooling when available; do not hand-format code.
- Write tests for public behavior and regressions, not implementation details.
